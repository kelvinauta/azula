Este es un proyecto que crea un RAG de inteligencia artificial, concretamente la parte de Agent consiste en la logica del agente de AI, El servicio de Agent tiene su propia DB separada del resto de servicios, ademas de Agent existe otros servicios que funcionan con una logica separada y modular, estos servicios son: Bulks (Se almacena documentos de knowledge que los agents pueden consultar por informacion) Tools (Son Scripts que los Agents pueden usar para ejecutar acciones, usualmente consultas a API)' 

src/Services/Agent/.deprecated.db/.md
El proyecto descrito parece ser un sistema de inteligencia artificial para un 'RAG' (puede referirse a un 'Retrieval-Augmented Generation' o un 'Resource Allocation Graph', dependiendo del contexto). La descripción que das sugiere que este sistema está estructurado en varios servicios modulares, cada uno dedicado a funciones específicas dentro del ecosistema de inteligencia artificial. Vamos a desglosar los componentes mencionados:

1. **Agent**: Representa la lógica principal del agente de inteligencia artificial. Este servicio tiene su propia base de datos, separada del resto, lo que indica que maneja datos críticos

```javascript
# db
Carpeta donde se guardan scripts de base de datos

# Dependencies
- postgresDB
- sequelize
```
---
src/Services/Agent/.deprecated.db/models/index.js
Este código define un conjunto de modelos utilizando Sequelize, una biblioteca ORM (Object-Relational Mapping) para Node.js, para gestionar una base de datos relacional relacionada con un sistema de inteligencia artificial. La estructura general del sistema se centra en la lógica del agente de inteligencia artificial (AI) y está dividida en varios servicios modulares: `Agents`, `Bulks`, y `Tools`.

### Descripción de los Modelos:

1. **Agents**: Representa los agentes de AI, con campos como `id`, `name`, `description`, y `config`. Este es un modelo central que define las características

```javascript
import { DataTypes } from 'sequelize';
function Models(sequelize) {
    const Agents = sequelize.define('Agents', {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true,
        },
        description: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        config: {
            type: DataTypes.JSON,
            allowNull: false,
        }
    }, {
        paranoid: true,
    });
    const Prompts = sequelize.define('Prompts', {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        title: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        prompt: {
            type: DataTypes.TEXT,
            allowNull: false,
        },
        config: {
            type: DataTypes.JSON,
            allowNull: false,
        },
    }, {
        paranoid: true,
    });
    const Bulks = sequelize.define('Bulks', {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        external_id: {
            type: DataTypes.UUID,
            allowNull: false,
        },
        config: {
            type: DataTypes.JSON,
            allowNull: false,
        },
    }, {
        paranoid: true,
    });
    const Tools = sequelize.define('Tools', {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        external_id: {
            type: DataTypes.UUID,
            allowNull: false,
        },
        config: {
            type: DataTypes.JSON,
            allowNull: false,
        },
    }, {
        paranoid: true,
    });
    const Chats = sequelize.define('Chats', {
        origin: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        last_interaction: {
            type: DataTypes.DATE,
            allowNull: true,
        },
    }, {
        paranoid: true,
    });

    const Humans = sequelize.define('Humans', {
        type: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        info: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
    }, {
        paranoid: true,
    });

    const Messages = sequelize.define('Messages', {
        type: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        text: {
            type: DataTypes.ARRAY(DataTypes.STRING),
            allowNull: true,
        },
        files: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
    }, {
        paranoid: true,
    });
    const Threads = sequelize.define('Threads', {
        tokens: {
            type: DataTypes.INTEGER,
            allowNull: true,
        },
        duration_ms: {
            type: DataTypes.INTEGER,
            allowNull: true,
        },
        logs: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_agents_used: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_bulks_used: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_tools_used: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_input_messages: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_output_messages: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_history_messages: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_request: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_response: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
    });

    const AgentsBulks = sequelize.define('AgentsBulks', {
        _agent: {
            type: DataTypes.UUID,
            references: {
                model: Agents,
                key: 'id',
            },
        },
        _bulk: {
            type: DataTypes.UUID,
            references: {
                model: Bulks,
                key: 'id',
            },
        },
    });
    const AgentsTools = sequelize.define('AgentsTools', {
        _agent: {
            type: DataTypes.UUID,
            references: {
                model: Agents,
                key: 'id',
            },
        },
        _tool: {
            type: DataTypes.UUID,
            references: {
                model: Tools,
                key: 'id',
            },
        },
    });
    Agents.belongsToMany(Bulks, {
        through: AgentsBulks,
    });
    Bulks.belongsToMany(Agents, {
        through: AgentsBulks,
    });
    Agents.belongsToMany(Tools, {
        through: AgentsTools,
    });
    Tools.belongsToMany(Agents, {
        through: AgentsTools,
    });
    Agents.hasMany(Messages,{ 
        foreignKey: '_agent',
        onDelete: 'RESTRICT',
        onUpdate: 'CASCADE',
    });
    Humans.hasMany(Messages,{
        foreignKey: '_human',
        onDelete: 'RESTRICT',
        onUpdate: 'CASCADE',
    });
    Chats.hasMany(Messages,{
        foreignKey: {
            name: '_chat',
            allowNull: false,
        },
        onDelete: 'RESTRICT',
        onUpdate: 'CASCADE',
    });
    Messages.belongsTo(Agents,{
        foreignKey: '_agent'
    });
    Messages.belongsTo(Humans,{
        foreignKey: '_human'
    });
    Messages.belongsTo(Chats,{
        foreignKey: '_chat'
    });

    Messages.hasMany(Threads,{
        foreignKey: '_input_message'
    });
    Messages.hasMany(Threads,{
        foreignKey: '_output_message'
    });
    Threads.belongsTo(Messages,{
        foreignKey: '_input_message'
    });
    Threads.belongsTo(Messages,{
        foreignKey: '_output_message'
    });
    return [Agents, Prompts, Bulks, Tools, Chats, Humans, Messages, AgentsBulks, AgentsTools, Threads];
}

export default Models;
    ```
---
src/Services/Agent/configs/.md
El texto proporcionado no es un código sino una descripción general de un proyecto que implica el desarrollo de un sistema de inteligencia artificial conocido como RAG (Retrieve and Generate). Aquí tienes una explicación sobre lo que hace cada componente mencionado en el texto:

1. **Agent**: 
   - El núcleo de este módulo es la lógica del agente de inteligencia artificial. Controla el comportamiento y las decisiones de los agentes dentro del sistema.
   - Tiene su propia base de datos (DB) separada para almacenar datos relevantes específicamente para los agentes, lo que posiblemente mejora la eficiencia y la gestión de datos al mantenerlos organizados y

```javascript
# Configs
Aquí se guarda todas la configuraciones que puedan ser necesarias en la API
```
---
src/Services/Agent/configs/db_config.js
El código que proporcionaste parece formar parte de un sistema que implementa un RAG (Retriever-Augmented Generation) de inteligencia artificial. En particular, el código define una configuración para interactuar con una base de datos que es utilizada por el servicio 'Agent'. El servicio 'Agent' maneja la lógica del agente de inteligencia artificial y tiene su propia base de datos, separada de otros servicios.

Otros servicios mencionados son:
1. **Bulks**: Almacena documentos de conocimiento que los agentes pueden consultar para obtener información.
2. **Tools**: Proporciona scripts que los agentes pueden usar para ejecutar

```javascript
const DB_CONFIG = {
    schema_template:{
        // Crear tablas si no existen
        create_tables_if_not_exists: true,
        
        // Crear columnas si no existen en el template
        create_columns_if_not_exists_in_template: true,
        
        // Eliminar referencias en cascada o cambiar a null
        references_delete_cascade: true,
        
        // No eliminar columnas que no estén en el template
        delete_columns_if_not_exists_in_template: false,

        // Si es true: las columnas deben ser las mismas en la tabla y en el template, 
        // Si es false: sólo se comprobará que las columnas existan
        validate_strict_columns: false,

        // Si es true: las tablas deben ser las mismas en la tabla y en el template, 
        // Si es false: sólo se comprobará que las tablas existan
        validate_strict_tables: false,
    }
}

export default DB_CONFIG
```
---
src/Services/Agent/controllers/channel.js
El código que has proporcionado parece ser parte de un sistema modular de inteligencia artificial en el que varios agentes y entidades humanas interactúan entre sí mediante mensajes en chats. A continuación, resumo lo que hace cada parte clave del código:

1. **Importaciones y configuración**:
   - Importa varios módulos y clases necesarias, incluyendo un proveedor de base de datos, validaciones de tipo mediante `superstruct`, y modelos de base de datos como `Chats`, `Messages`, `Agents`, y `Humans`.
   - Importa un módulo para componer mensajes denominado `Composer`.

2. **Clase `Channel`**

```javascript
import Provider from '../db/provider';
import { assert, mask, instance, define, object } from 'superstruct';
import { Op } from 'sequelize';
import Chat from '../db/tables/Chats';
import Message from '../db/tables/Messages';
import Agent from '../db/tables/Agents';
import Human from '../db/tables/Humans';
import Composer from './composer.js';
class Channel {
    static schema = object({ // TODO: los input y output schemas compartidos deberian estar en un archivo aparte
        sender: define(
            'sender',
            (sender) =>
                sender instanceof Agent.instance.model ||
                sender instanceof Human.instance.model,
        ),
        receiber: define(
            'receiber',
            (sender) =>
                sender instanceof Agent.instance.model ||
                sender instanceof Human.instance.model,
        ),
        chat: define('chat', (chat) => chat instanceof Chat.instance.model),
        message: define(
            'message',
            (message) => message instanceof Message.instance.model,
        ),
    });
    constructor(proxy) {
        this.proxy = proxy; // TODO: Validate instance of proxy
    }
    async sender({ sender, receiver, chat, message, sender_type }) {
        if (!Provider.all_is_ok()) throw new Error('Provider not initialized');
        assert(chat, object(Chat.schema));
        assert(message, object(Message.schema));

        const mask_chat = mask(chat, object(Chat.schema));
        const mask_message = mask(message, object(Message.schema));

        if (!mask_chat.external_id && !mask_chat.id)
            throw new Error('Invalid chat');

        const chat_row = await Chat.instance.touch_one(mask_chat);
        const message_row = await Message.instance.touch_one({
            ...mask_message,
            [Chat.instance.foreign_key_name]: chat_row.id,
            [`${sender.table.foreign_key_name}`]: sender.row.id,
        });

        return {
            sender: sender.row,
            chat: chat_row,
            message: message_row,
        };
    }

    async sender_human({ human, agent, chat, message }) {
        if (!Provider.all_is_ok()) throw new Error('Provider not initialized');
        assert(human, object(Human.schema));
        assert(agent.id, Agent.schema.id);
        const mask_human = mask(human, object(Human.schema));
        if (!mask_human.external_id && !mask_human.id)
            throw new Error('Invalid human'); // TODO: Validate Human debería ser como Validate Message
        const agent_row = await (await Agent.getInstance()).getAgent(agent.id);

        const human_row = await Human.instance.touch_one(mask_human);
        const receiver_human = this.sender({
            sender: {
                table: Human.instance,
                row: human_row,
            },
            receiver: {
                table: Agent.instance,
                row: agent_row,
            },
            chat,
            message,
            sender_type: Human.instance.foreign_key_name,
        });
        const composer = new Composer()
        await composer.build(receiver_human)
    }

    async sender_agent({ agent_id, chat, message }) {
        if (!Provider.all_is_ok()) throw new Error('Provider not initialized');
        assert(agent_id, Agent.schema.id);
        if (!agent_id) throw new Error('Agent id is required');
        if (!chat) throw new Error('Chat is required');
        if (!message) throw new Error('Message is required');
        assert(chat, object(Chat.schema));
        assert(message, object(Message.schema));
        const agent = await Agent.getInstance();
        const agent_row = await agent.getAgent(agent_id);
        if (!agent_row) throw new Error('Invalid agent');
        return this.sender({
            sender: {
                table: Agent.instance,
                row: agent_row,
            },
            chat,
            message,
            sender_type: Agent.instance.foreign_key_name,
        });
    }
}

export default Channel;
```
---
src/Services/Agent/controllers/composer.js
El código proporcionado pertenece a un proyecto que implementa un sistema de inteligencia artificial (IA) conocido como RAG (que generalmente se refiere a sistemas de 'Respuesta Automatizada en Grupos'). Este sistema está compuesto por varios servicios, entre los cuales destaca el 'Agent', encargado de la lógica del agente de IA. Los servicios están estructurados en módulos separados, cada uno cumpliendo funciones específicas, como almacenar documentos de conocimiento ('Bulks') y ejecutar scripts para los agentes ('Tools').

El código incluye la implementación de una clase llamada `Composer`. El principal objetivo de esta clase es gestionar las interacciones dentro del sistema

```javascript
import Channel from './channel.js'
import Human from '../db/tables/Humans';
import Chat from '../db/tables/Chats.js'
import Agent from '../db/tables/Agents.js'
import { assert, mask, instance, define, object } from 'superstruct';
class Composer{
    constructor(){

    }
    async validate(msg_received){
        assert(msg_received, Channel.schema)
        if(!(msg_received.sender instanceof (await Human.getInstance()).model)) throw new Error('msg_received mus be of the a Human')
    }
    async getData({
      sender,
      receiver,
      chat,
      message,
      
    }){
      const history_chat = await (await Chat.getInstance()).getHistoryChat(chat)
      const context_chat  = await (await Chat.getInstance()).getContextChat(chat)
      const config_agent = await (await Agent.getInstance()).getConfig(receiver.row)
      const human_info = await (await Human.getInstance()).getInfoHuman(sender.row)
      return {
        message,
        history_chat,
        context_chat,
        config_agent,
        human_info
      } 
    }
    async build(receiver_human){
      this.#validate(receiver_human);
      const data = await getData() 
    }
    request(){

    }
    #validate(){

    }
}

export default Composer
```
---
src/Services/Agent/db/.md
El proyecto mencionado parece implementar un sistema de generación de conocimiento mediante la creación de un 'RAG' (posiblemente se refiere a 'Recurrent AI Generators' o algo similar relacionado con inteligencia artificial). El proyecto se compone de distintas partes o módulos, cada uno con una responsabilidad específica y lógica modular.

1. **Agent**: Es una parte fundamental del sistema y parece ser la componente principal. La lógica del agente de inteligencia artificial está contenida en este módulo, sugiriendo que 'Agent' es el corazón del sistema donde se toman decisiones y se ejecutan acciones basadas en el conocimiento acumulado o las

```javascript
```
---
src/Services/Agent/db/factory/AgentFactory.js
El código presentado es parte de un proyecto que desarrolla un sistema de inteligencia artificial usando un enfoque basado en un gráfico de acción de recuperación (RAG por sus siglas en inglés). En el contexto del código, se describe la función y estructura del componente 'Agent' del sistema, que gestiona la lógica de los agentes de IA y opera con su propia base de datos. Además, existen otros servicios mencionados como 'Bulks' y 'Tools', cada uno con una lógica separada y modular. Los 'Bulks' almacenan documentos que pueden ser consultados por los agentes, mientras que 'Tools' ofrece scripts

```javascript
import Agent from '../tables/Agents';
import Provider from '../provider';
import { assert, object, string } from 'superstruct';
class AgentFactory {
    constructor(agent_table_intance){
        this.agent_table_intance = agent_table_intance;
        this.#validate();
    }
    #validate(){
        if(!this.agent_table_intance) throw new Error('agent_table_intance table is required');
        if(!(this.agent_table_intance instanceof Agent)) throw new Error('agent_table_intance table is invalid');
        if(!Provider.instance) throw new Error('Provider is required');
        if(!Provider.all_is_ok()) throw new Error('Provider is not ready');
    }

    async simple(agent_data){
        this.#validate();
        assert(agent_data, object(this.agent_table_intance.constructor.schema));
        return await this.agent_table_intance.model.create(agent_data);
    }
}
export default AgentFactory;
```
---
src/Services/Agent/db/functions/init_db.js
El código proporcionado es parte de un sistema que configura y gestiona una base de datos para un proyecto de inteligencia artificial (IA) con un enfoque de agente RAG (Retriever-Augmented Generation). El archivo parece querer iniciar o preparar la base de datos y las tablas asociadas para su uso. 

### Función principal: `init_db`

La función principal en este código es `init_db`, que realiza las siguientes acciones:

1. **Conexión a la base de datos**: Utiliza `Postgres.getInstance()` para obtener una instancia de la conexión a la base de datos y luego la conecta con

```javascript
import Postgres from '../postgres';
import _Table from '../tables/_Table';
import Agent from '../tables/Agents';
import Bulk from '../tables/Bulks';
import Chat from '../tables/Chats';
import Human from '../tables/Humans';
import Message from '../tables/Messages';
import Prompt from '../tables/Prompts';
import Tool from '../tables/Tools';
import Thread from '../tables/Threads';

export default async function init_db() {
    const db = Postgres.getInstance();
    await db.connect();

    // In order of priority/relations
    const agents = new Agent(db);
    const prompts = new Prompt(db);
    const bulks = new Bulk(db);
    const tools = new Tool(db);
    const chats = new Chat(db);
    const humans = new Human(db);
    const messages = new Message(db);
    const threads = new Thread(db);
    const relations_many_to_many = [
        agents.many_to_many(bulks),
        agents.many_to_many(tools),
    ];
    messages.ref(agents);
    messages.ref(humans);
    messages.ref(chats);
    threads.ref(messages, '_input_message');
    threads.ref(messages, '_output_message');
    await agents.sync();
    await bulks.sync();
    await prompts.sync();
    await tools.sync();
    await chats.sync();
    await humans.sync();
    await messages.sync();
    await threads.sync();

    for (const relation of relations_many_to_many) {
        await relation.sync();
    }
}
```
---
src/Services/Agent/db/postgres.js
Este código implementa un patrón de diseño Singleton para gestionar conexiones a una base de datos PostgreSQL utilizando la librería Sequelize. Forma parte de la estructura de un proyecto más grande que, basado en la descripción, parece ser un sistema de RAG (Retrieval-Augmented Generation) de inteligencia artificial. 

### Descripción del Código:

1. **Clase `Postgres`**:
   - **Propiedad estática `instance`**: Permite asegurar que solo exista una instancia de la clase `Postgres`, garantizando que la conexión a la base de datos sea única.
   - **Método `getInstance

```javascript
import { Sequelize } from 'sequelize';
// import Logger from 'tuki_logger' // TODO: Mejor Logger

// * Lib sequelize
class Postgres {
    static instance = null;
    #logger;

    // * Get instance
    static getInstance() {
        if(Postgres.instance) return Postgres.instance;
        Postgres.instance = new Postgres();
        return Postgres.instance;
    }

    constructor() {
        if (Postgres.instance) throw new Error('This is a singleton class use .getInstance()')
        Postgres.instance = this;

        this.is_connected = false;
        this.sequelize = new Sequelize(process.env.POSTGRES_DB, process.env.POSTGRES_USER, process.env.POSTGRES_PASSWORD, {
            host: process.env.POSTGRES_HOST,
            port: process.env.POSTGRES_PORT,
            dialect: 'postgres',
            logging: false,
        })

        
        // this.#logger = new Logger({title: 'Postgres'});
    }
    // * Public methods
    async connect() {
        try {
            // this.#logger.status('Connecting to Postgres')
            console.log('Connecting to Postgres');
            await this.sequelize.authenticate();
            this.is_connected = true;
            console.log('Postgres connected');
            // this.#logger.success('Postgres connected')
            return this;
        } catch (error) {
            // this.#logger.error(error)
            this.is_connected = false;
            throw error
        }
    }
    
    async getTablesSchemas() {
        // this.#logger.status('Getting tables schemas')
        try {
            const query = `
                SELECT 
                    t.table_name,
                    c.column_name,
                    c.data_type,
                    c.character_maximum_length,
                    c.is_nullable,
                    c.column_default
                FROM 
                    information_schema.tables t
                    JOIN information_schema.columns c ON t.table_name = c.table_name
                WHERE 
                    t.table_schema = 'public'
                ORDER BY 
                    t.table_name,
                    c.ordinal_position;
            `;
            
            const [results] = await this.sequelize.query(query);
            
            // Organizar los resultados por tabla
            const schemas = {};
            results.forEach(row => {
                if (!schemas[row.table_name]) {
                    schemas[row.table_name] = {
                        columns: []
                    };
                }
                
                schemas[row.table_name].columns.push({
                    name: row.column_name,
                    type: row.data_type,
                    maxLength: row.character_maximum_length,
                    nullable: row.is_nullable === 'YES',
                    default: row.column_default
                });
            });
            
            return schemas;
        } catch (error) {
            // this.#logger.error('Error obteniendo esquemas de tablas:', error);
            throw error;
        }
    }

}

export default Postgres


// * Lib postgres.js
// class Postgres {
//     constructor() {
        
//         // private
//         this.logger = new Logger({title: 'Postgres'})
//         this.rules = new Rules('Postgres')
//         this.sql = _postgres({
//             host: process.env.POSTGRES_HOST,
//             port: process.env.POSTGRES_PORT,
//             database: process.env.POSTGRES_DB,
//             user: process.env.POSTGRES_USER,
//             password: process.env.POSTGRES_PASSWORD,
//             debug: (...data) => this._debug(...data)
//         })
//     }

//     async get_sql() {
//         return this.sql
//     }

//     // private methods
//     _debug(...data){
//         // this.logger.info(...data)
//     }

// }

```
---
src/Services/Agent/db/provider/index.js
El código proporciona la estructura de un sistema que se utiliza para crear un RAG (Retrieval-Augmented Generation), una arquitectura de inteligencia artificial que incluye múltiples componentes modulares y servicios separados. El enfoque principal del código es la clase `Provider`, que actúa como un singleton para gestionar y sincronizar interacciones con una base de datos PostgreSQL y tablas relacionadas.

### Componentes del Código:

- **Postgres**: Importado posiblemente como un módulo para manejar las conexiones a la base de datos PostgreSQL.
- **_Table, Agent, Bulk, Chat, Human, Message, Prompt, Tool, Thread**:

```javascript
import Postgres from '../postgres';
import _Table from '../tables/_Table';
import Agent from '../tables/Agents';
import Bulk from '../tables/Bulks';
import Chat from '../tables/Chats';
import Human from '../tables/Humans';
import Message from '../tables/Messages';
import Prompt from '../tables/Prompts';
import Tool from '../tables/Tools';
import Thread from '../tables/Threads';
import {assert, object, define, is} from 'superstruct';
 class Provider { // singleton
    static instance = null;
    static #instance_with_build = false;
    static #db_ok = false;
    static #sync_ok = false;
    static tables_schema = define('tables_schema', (tables)=>{
        if(typeof tables !== 'object') return false;
        if(!Object.values(tables).every((table)=> table instanceof _Table)) return false;
        return true;
    });

    static async build(){
        if(Provider.instance && Provider.#instance_with_build) return Provider.instance;

        //validate
        Provider.#instance_with_build = true;
        const provider = new Provider();
        await provider.#_build();
        Provider.instance = provider;
        return provider;
    }
    constructor() {
        if(!Provider.#instance_with_build) throw new Error('first constructor is disabled, use build() instead');
        if(Provider.instance) return Provider.instance;
        this.db = Postgres.getInstance();
        this.tables = {};
    }
    static all_is_ok(){
        return Provider.#db_ok && Provider.#sync_ok;
    }
    async #_build(){
        await this.db.connect();
        Provider.#db_ok = true;
        const agents = await Agent.getInstance();
        const prompts = await Prompt.getInstance();
        const bulks = await Bulk.getInstance();
        const tools = await Tool.getInstance();
        const chats = await Chat.getInstance();
        const humans = await Human.getInstance();
        const messages = await Message.getInstance();
        const threads = await Thread.getInstance();
        const relations_many_to_many = [
            await agents.many_to_many(bulks),
            await agents.many_to_many(tools),
        ];
        messages.ref(agents);
        messages.ref(humans);
        messages.ref(chats);
        threads.ref(messages, '_input_message');
        threads.ref(messages, '_output_message');
        await agents.sync();
        await bulks.sync();
        await prompts.sync();
        await tools.sync();
        await chats.sync();
        await humans.sync();
        await messages.sync();
        await threads.sync();
    
        for (const relation of relations_many_to_many) {
            await relation.sync();
            this.tables[relation.get_name()] = relation;
        }
        this.tables[agents.get_name()] = agents;
        this.tables[prompts.get_name()] = prompts;
        this.tables[bulks.get_name()] = bulks;
        this.tables[tools.get_name()] = tools;
        this.tables[chats.get_name()] = chats;
        this.tables[humans.get_name()] = humans;
        this.tables[messages.get_name()] = messages;
        this.tables[threads.get_name()] = threads;
        Provider.#sync_ok = true;
    }

    getTables(){
        if(!this.tables) throw new Error('Tables not built');
        assert(this.tables, Provider.tables_schema);
        return this.tables;
    }
    

}

export default Provider;
```
---
src/Services/Agent/db/tables/Agents.js
El código pertenece a un proyecto que implementa un sistema de inteligencia artificial mediante RAG (Retrieval Augmented Generation). El enfoque principal es la creación de un componente denominado 'Agent', que comprende la lógica del agente de inteligencia artificial. En este contexto, el código se centra en definir la estructura y la funcionalidad de la base de datos relacionada específicamente con los agentes de IA.

### Descripción del Contenido:

1. **Importaciones y Configuración de Tipos de Datos:**
   - Se importan módulos de soporte como `_Table` (probablemente una clase base para manejar modelos de datos) y se utilizan

```javascript
import _Table from './_Table.js';
import { DataTypes } from 'sequelize';
import { object, string, define, optional } from 'superstruct';
import isUuid from 'is-uuid';

class Agent extends _Table {
    static attributes = {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true,
        },
        description: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        config: {
            type: DataTypes.JSON,
            allowNull: false,
        },
    };
    static schema = {
        id: optional(define('id', (value) => isUuid.v4(value))),
        name: string(),
        description: optional(string()),
        config: object({
            prompt: string(),
            model: string(),
        }),
    }
    static options = {
        paranoid: true,
    };
    constructor(...all) {
        super(...all);
    }
    async getAgent(id) {
        const agent = await this.model.findOne({ where: { id } });
        if (!agent) throw new Error('Agent not found');
        return agent;
    }
}
export default Agent;
```
---
src/Services/Agent/db/tables/Bulks.js
El código describe una parte de un sistema que emplea inteligencia artificial para crear un **RAG** (posiblemente se refiere a un Generador de Respuestas Automáticas) compuesto por diversos servicios modulares. El fragmento dado se centra en la definición de una clase que parece formar parte del servicio de 'Bulks'. La clase `Bulk` hereda de una clase base `Table` y utiliza `Sequelize`, que es un ORM (Object-Relational Mapping) para Node.js, para definir la estructura y el comportamiento de un modelo de base de datos.

Aquí desglosamos las características principales del código

```javascript
import _Table from './_Table.js';
import { DataTypes } from 'sequelize';

class Bulk extends _Table {
    static attributes = {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        external_id: {
            type: DataTypes.UUID,
            allowNull: false,
        },
        config: {
            type: DataTypes.JSON,
            allowNull: false,
        },
    };
    static options = {
        paranoid: true,
    };
    constructor(...all) {
        super(...all);
    }
}

export default Bulk;
```
---
src/Services/Agent/db/tables/Chats.js
El código presentado pertenece a un proyecto de inteligencia artificial que crea un RAG (Retriever-Augmented Generation). Este proyecto está compuesto por varios servicios modulares, entre ellos el servicio Agent, que es responsable de la lógica del agente de inteligencia artificial. Cada servicio tiene su propia base de datos; en este caso, el servicio Agent tiene su propia base de datos separada de otros servicios como Bulks y Tools.

- **Chat Class**: El fragmento del código que has proporcionado define una clase llamada `Chat`, que extiende de una clase llamada `_Table`. Esta clase `Chat` probablemente representa un modelo de datos

```javascript
import _Table from './_Table'
import {DataTypes} from 'sequelize'
import { string, define, is, date, object, optional } from 'superstruct'
import isUuid from 'is-uuid'
class Chat extends _Table {
    static attributes = {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        external_id: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        origin: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        last_interaction: {
            type: DataTypes.DATE,
            allowNull: true,
        },
    }
    static schema = {
        id: optional(define('id', (value) => isUuid.v4(value))),
        external_id: optional(string()),
        origin: optional(string()),
        last_interaction: optional(date()),
    }
    constructor(...all) {
        super(...all);
    }
}

export default Chat
```
---
src/Services/Agent/db/tables/Humans.js
El código que proporcionaste define una clase llamada `Human` que extiende de una clase base denominada `_Table`, la cual parece formar parte de un sistema más grande, posiblemente un sistema de inteligencia artificial distribuido denominado 'RAG' (probablemente un acrónimo de una funcionalidad en inteligencia artificial). Aquí se detalla lo que hace este código:

1. **Imports**:
   - Importa `_Table` desde un módulo (posiblemente una clase base para manejar estructuras de tablas o modelos).
   - Importa `DataTypes` de `sequelize` para definir los tipos de datos en un modelo de base de

```javascript
import _Table from './_Table'
import {DataTypes} from 'sequelize'
import { object, string,  define, optional} from 'superstruct'
import isUuid from 'is-uuid'
class Human extends _Table {
    static attributes = {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        external_id: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        type: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        info: {
            type: DataTypes.JSONB,
            allowNull: true,
        }
    }
    static schema = {
        id: optional(define('id', (value) => isUuid.v4(value))),
        external_id: optional(string()),
        type: optional(string()),
        info: optional(object()),
    }
    constructor(...all) {
        super(...all);
    }
}
export default Human   
```
---
src/Services/Agent/db/tables/Messages.js
Este fragmento de código parece ser parte de un proyecto más amplio que involucra un sistema de inteligencia artificial llamado RAG (posiblemente 'Retrieval-Augmented Generation'). Esta parte específica del código se enfoca en la lógica de gestión de mensajes dentro del servicio del agente, que es uno de los componentes del sistema. El texto de introducción del código sugiere que el sistema tiene varios servicios que funcionan de manera modular.

El principal componente del código es la clase `Message` que hereda de `_Table`. Esta clase gestiona la estructura de un mensaje dentro de la base de datos utilizando 'Sequelize',

```javascript
import _Table from './_Table'
import {DataTypes} from 'sequelize'
import { object, string, array, define, optional, enums, assert } from 'superstruct'
import isUuid from 'is-uuid'
class Message extends _Table {
    static attributes = {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        type: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        texts: {
            type: DataTypes.ARRAY(DataTypes.STRING),
            allowNull: true,
        },
        files: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
    }
    static validate_message_schema (msg){
        try{
            assert(msg, object(Message.schema))
            assert(msg.type, enums(['received', 'sent']))
    
            function validate_texts(msg_texts){
                if(!msg_texts) return false;
                if(!Array.isArray(msg_texts)) return false;
                if(msg_texts.length === 0) return false;
                if(msg_texts.some((txt)=>typeof txt !== 'string')) return false;
                return true
            }
            function validate_files(msg_files){
                if(!msg_files) return false;
                if(!Array.isArray(msg_files)) return false;
                if(msg_files.length === 0) return false;
                if(msg_files.some((file)=>typeof file !== 'object')) return false;
                return true
            }
            if(!(validate_texts(msg.texts) || validate_files(msg.files))) throw new Error('Message Received no valid')
            return true
        }catch(e){
            return false
        }
    }
    static schema = {
        id: optional(define('id', (value) => isUuid.v4(value))),
        type: optional(string()),
        texts: optional(array(string())),
        files: optional(array(object())),
    }
    
    constructor(...all) {
        super(...all);
    }
}

export default Message
```
---
src/Services/Agent/db/tables/Prompts.js
El código describe una clase llamada `Prompt` que es parte de un sistema de inteligencia artificial con diferentes servicios modulares. La clase `Prompt` extiende otra clase llamada `_Table` que, presumiblemente, maneja la interacción con una base de datos usando Sequelize, un ORM (Object-Relational Mapping) para Node.js.

1. **Atributos de la Clase Prompt:**
   - `id`: Un identificador único para cada entrada, que se genera automáticamente usando UUID v4.
   - `title`: Un campo de texto que representa el título del prompt.
   - `prompt`: Un campo de

```javascript
import _Table from './_Table.js';
import { DataTypes } from 'sequelize';

class Prompt extends _Table {
    static attributes = {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        title: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        prompt: {
            type: DataTypes.TEXT,
            allowNull: false,
        },
        config: {
            type: DataTypes.JSON,
            allowNull: false,
        },
    };
    static options = {
        paranoid: true,
    };
    constructor(...all) {
        super(...all);
    }
}

export default Prompt;
```
---
src/Services/Agent/db/tables/Threads.js
Este código define una clase `Thread` que parece ser parte de un sistema más grande para manejar la lógica de un agente de inteligencia artificial dentro de un RAG (Retrieval-Augmented Generation). La funcionalidad del agente AI parece estar dividida en varios servicios, como `Agent`, que contiene la lógica del agente y utiliza su propia base de datos; `Bulks`, donde se almacenan documentos que los agentes pueden consultar; y `Tools`, que son scripts para realizar acciones, usualmente a través de consultas a APIs.

La clase `Thread` extiende una clase base `_Table`, lo que sugiere que

```javascript
import _Table from './_Table'
import {DataTypes} from 'sequelize'
class Thread extends _Table {
    static attributes = {
        tokens: {
            type: DataTypes.INTEGER,
            allowNull: true,
        },
        duration_ms: {
            type: DataTypes.INTEGER,
            allowNull: true,
        },
        logs: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_agents_used: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_bulks_used: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_tools_used: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_input_messages: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_output_messages: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_history_messages: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_request: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        raw_response: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
    }
    constructor(...all) {
        super(...all);
    }
}

export default Thread
```
---
src/Services/Agent/db/tables/Tools.js
El fragmento de código presentado parece ser parte de un proyecto que implementa una arquitectura modular para un sistema de inteligencia artificial, enfocándose en un componente específico: herramientas (Tools). Este proyecto incluye varias partes o servicios modulares, entre los cuales se encuentra un servicio llamado 'Agent' para la lógica de los agentes de IA, 'Bulks' para almacenar documentos de conocimiento, y 'Tools' para ejecutar scripts o acciones específicas, como las consultas a API.

En el código proporcionado, se define una clase llamada `Tool` que hereda de `_Table`, y parece ser parte de un módulo que maneja la

```javascript
import _Table from './_Table'
import {DataTypes} from 'sequelize'
class Tool extends _Table {
    static attributes = {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
        external_id: {
            type: DataTypes.UUID,
            allowNull: false,
        },
        config: {
            type: DataTypes.JSON,
            allowNull: false,
        },
    }
    constructor(...all) {
        super(...all);
    }
}

export default Tool
```
---
src/Services/Agent/db/tables/_Table.js
Este código es parte de un proyecto que crea un sistema RAG (Retriever-Augmented Generation) de inteligencia artificial, en el que se maneja la lógica de un agente de AI y su interacción con una base de datos (DB) en Postgres, utilizando Sequelize como ORM (Object-Relational Mapping). 

**Resumen del código:**

1. **Importaciones y uso de librerías**: Utiliza librerías como `sequelize` para la gestión de la base de datos, y `superstruct` para la validación de esquemas de datos.

2. **Clase `_Table`**:
   - **

```javascript
import Postgres from '../postgres';
import { DataTypes, Model } from 'sequelize';
import {assert, enums, define, object, string, number, array} from 'superstruct';
import isUuid from 'is-uuid';
class _Table {
    static instance = null;
    static is_synced = false;
    static db = null;

    

    static attributes = {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            allowNull: false,
            primaryKey: true,
        },
    };
    static options = {
        paranoid: true,
    };
    static schema = {
        id: define('id', (value) => isUuid(value)),
    };

    static async getInstance(params){
        if(this.name === _Table.name) throw new Error('Table cannot be instantiated');  
        if(this.instance) return this.instance;
        await this.db_connected();
        const instance = new this(params);
        this.instance = instance;
        return instance;
    }
    static async db_connected(){
        
        let db;
        if(_Table.db && _Table.db instanceof Postgres) db = _Table.db;
        else{
            db = Postgres.getInstance();
            await db.connect();
            _Table.db = db;
        }
        this.db = db;
    }
    constructor(params) {
        if (!this.constructor.db ) throw new Error('Db is required');
        this.#validate_db();
        if(this.constructor.instance) return this.constructor.instance;
        if (params) {
            if(typeof params !== 'object') throw new Error('Params must be an object');
            const params_schema = object({
                name: string(),
                attributes: object(),
                options: object(),
            });
            assert(params, params_schema);
        }

        // logic
        this.db = this.constructor.db;
        this.params = params || {
            name: this.constructor.name,
            attributes: this.constructor.attributes,
            options: this.constructor.options,
        };

        this.sequelize = this.db.sequelize;
        this.foreign_key_name = `_${this.params.name.toLowerCase()}`;

        this.model = this.sequelize.define(
            this.params.name,
            this.params.attributes,
            this.params.options
        );
    }
    get_name(){
        return this.params.name;
    }

    async sync() {
        this.#validate_db();
        this.constructor.is_synced = true;
        return await this.model.sync({ alter: true });
    }
    ref(ref_table, foreign_key_name) {
        // validate
        if (foreign_key_name && typeof foreign_key_name !== 'string')
            throw new Error('foreign_key_name must be a string');
        if (!ref_table) throw new Error('ref_table is required');
        if (!(ref_table instanceof _Table))
            throw new Error('ref_table must be an instance of _Table');
        if (!Object.prototype.isPrototypeOf.call(Model, ref_table.model))
            throw new Error('ref_table.model must be a Model class');
        // * logic
        // Read many to one sequelize docs
        // has many or has one is the same bassically
        foreign_key_name = foreign_key_name || ref_table.foreign_key_name;
        this.#validate_table(ref_table);
        this.model.belongsTo(ref_table.model, {
            foreignKey: foreign_key_name,
        });
        ref_table.model.hasMany(this.model, {
            foreignKey: foreign_key_name,
        });
    }
    async many_to_many(ref_table) {
        // validate
        this.#validate_table(ref_table);
        if(this.model.tableName === ref_table.model.tableName) throw new Error('Table must be different from the current table');
        // logic
        const params = this.#build_many2many_params(this, ref_table);
        class RelationTable extends _Table {}
        const relation_table = await RelationTable.getInstance(params);
        this.model.belongsToMany(ref_table.model, {
            through: relation_table.model,
        });
        ref_table.model.belongsToMany(this.model, {
            through: relation_table.model,
        });
        return relation_table;
    }

    async touch_one(where_params) {
        if (!where_params) throw new Error('Where params are required');
        if (typeof where_params !== 'object')
            throw new Error('Where params must be an object');

        let row = await this.model.findOne({ where: where_params });
        if (!row) row = await this.model.create(where_params);
        return row;
    }
    // * Private methods
    #build_many2many_params(tableA, tableB) {
        if (!tableA || !tableB)
            throw new Error('TableA and TableB are required');
        this.#validate_table(tableA);
        this.#validate_table(tableB);
        return {
            name: `${tableA.constructor.name}${tableB.constructor.name}`,
            attributes: {
                [`${tableA.foreign_key_name}`]: {
                    type: DataTypes.UUID,
                    references: {
                        model: tableA.model,
                        key: 'id',
                    },
                },
                [`${tableB.foreign_key_name}`]: {
                    type: DataTypes.UUID,
                    references: {
                        model: tableB.model,
                        key: 'id',
                    },
                },
            },
            options: {},
        };
    }
    #validate_table(table) {
        if (table === this) return true;
        if (!table) throw new Error('Table is required');
        if (!(table instanceof _Table))
            throw new Error('Table must be an instance of _Table');
        if (!table.model) throw new Error('Table must be defined');
        if (table.constructor.name === this.constructor.name)
            throw new Error('Table must be different from the current table');
        return true;
    }
    #validate_db(){
        if (!this.constructor.db ) throw new Error('Db is required');
        if(!this.constructor.db instanceof Postgres) throw new Error('Db is not connected');
        if (!this.constructor.db.is_connected)
            throw new Error('Db.is_connected is false');
    }
}

export default _Table;
```
---
src/Services/Agent/proxy.js
El código describe parte de un sistema de inteligencia artificial modular compuesto por varios servicios, entre los que destaca el servicio 'Agent'. Este fragmento de código se centra en la definición de una clase llamada `ProxyAgent`, encargada de la lógica del agente de inteligencia artificial. El servicio del agente dispone de su propia base de datos, separada de otros servicios como `Bulks` (para el almacenamiento de documentos de conocimiento) y `Tools` (scripts que los agentes pueden utilizar para ejecutar acciones, como consultas a APIs).

### Funcionalidad del Código:

1. **Importación de Módulos**: El código

```javascript
import { assert, object, string, define, type } from 'superstruct';
import Message from './db/tables/Messages';
import Channel from './controllers/channel';
import Provider from './db/provider';
class ProxyAgent {
    static input_schema = object({
        external_human_id: string(),
        external_chat_id: string(),
        origin_chat: string(),
        agent_id: string(),
        message: define('message', (msg) =>
            Message.validate_message_schema(msg),
        ),
    });
    constructor() {
        this.channel = new Channel();
    }
    run() {}
    async input(received) {
        assert(received, ProxyAgent.input_schema);
        await Provider.build();
        await this.channel.sender_human({
            human: {
                external_id: received.external_human_id,
                type: 'external', // TODO: Harcodeado, a futuro deberia poder se un humano interno como externo
            },
            chat: {
                external_id: received.external_chat_id,
                origin: received.origin_chat,
            },
            message: received.message,
            agent: {
                id: received.agent_id,
            },
        });
    }
    output() {}
    #validate() {}
}
export default ProxyAgent;
```
---
